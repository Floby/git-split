#!/bin/bash

SUPER_REPO=$1
SUBPATH=$2

MYDIR=$(dirname $0)
if [ $MYDIR != "." ]; then
    MYDIR=$(pwd)/$MYDIR
else
    MYDIR=$(dirname $(which $0))
fi

# . $MYDIR/../lib/all.sh


die() {
    echo $* 1>&2
    exit 1
}

cd $SUPER_REPO;
test -d $SUBPATH || die "no such subpath"

find_subtree() {
    tree=$1
    next=$(echo $2 | sed 's#/# #' | awk '{print $1}')
    left=$(echo $2 | sed 's#/# #' | awk '{print $2}')
    
    nexttree=$(git cat-file -p $tree | grep "$next" | grep tree | awk '{print $3}')

    if test -n "$left" ; then
        find_subtree $nexttree $left 
        return $?
    fi

    echo $nexttree
}

get_subpath_tree() {
    commit=$1
    tree=$(git cat-file -p $commit | head -1 | sed 's/^tree //')
    find_subtree $tree $SUBPATH
}

deref_commit() {
    commit=$1
    git show  $commit | head -1 | sed 's/^commit //'
}

current_tree=`get_subpath_tree HEAD`
previous_commit=`deref_commit HEAD`

for commit in `git rev-list HEAD` ; do
    subtree=`get_subpath_tree $commit`

    [ "$current_tree" = "$subtree" ] && continue
    current_tree=$subtree

    echo keeping commit $previous_commit
    git cat-file -p $previous_commit | sed -n '/^$/,$p' | tail -n +2
    echo

    previous_commit=$commit
done
