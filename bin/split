#!/bin/bash

SUPER_REPO=$1
SUBPATH=$2

# setup some path vars for our little project
SPLIT_BIN_DIR=$(dirname $0)
# if the dir is . then git-split is in the $PATH and likely to be symlinked
if [ $SPLIT_BIN_DIR != "." ]; then
    SPLIT_BIN_DIR=$(pwd)/$SPLIT_BIN_DIR
else
    SPLIT_BIN_DIR=$(dirname $(realpath $(which $0))) 
fi
SPLIT_ROOT=$SPLIT_BIN_DIR/..
SPLIT_LIB_DIR=$SPLIT_ROOT/lib

# source our libs
. $SPLIT_LIB_DIR/all.sh

# we change the working directory to the main repository
cd $SUPER_REPO;
# test if the thing we're trying to split apart exists at all
test -d $SUBPATH || die_usage 2 "no such subpath: $SUBPATH"

# list commits that affect a given subpath from a given branch
# usage: list_useful_commits <subpath> <branch>
#       subpath:    the subpath for which you want to scan changes
#       branch:     not used yet
list_useful_commits() {
    subpath=$1
    branch=HEAD

    # intialize these
    current_tree=`get_subpath_tree $branch`
    previous_commit=`deref_commit $branch`
    for commit in `git rev-list $branch` ; do
        subtree=`get_subpath_tree $commit $subpath`

        if [ "$current_tree" = "$subtree" ] ; then
            previous_commit=$commit
            continue
        fi
        current_tree=$subtree

        log keeping commit $previous_commit
        git cat-file -p $previous_commit | sed -n '/^$/,$p' | tail -n +2
        echo $previous_commit >> $commit_list
        log

        previous_commit=$commit
    done
}

commit_list=`mktemp`

list_useful_commits $SUBPATH

echo end of script
echo keeping these commits
cat $commit_list
rm $commit_list
